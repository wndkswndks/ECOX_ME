/***********************************************************************/
/*                                                                     */
/*  FILE        :EcoX.c                                                */
/*  DATE        :Mon, Jul 22, 2019                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :H8SX/1544                                             */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.16).    */
/*                                                                     */
/***********************************************************************/
             
                

/*****************************************************************************
Revised by		:	HDXWILL 시스템제어팀 임성수
Revision Date	:	2019.07.22
Revision number	:	
Revision Purpose:

*****************************************************************************/

/*_____ I N C L U D E S ____________________________________________________*/
#include "Includes.h"

/*_____ D E C L A R A T I O N ______________________________________________*/

/*_____ D E F I N E ________________________________________________________*/


/*_____ F U C T I O N ______________________________________________________*/
void ProcessCmd(void);
void ProcessCmd_LCD(void);
void Exhibition(BYTE);

// extern int ReadDegree_RO(int*);
/*_____ V A R I A B L E ____________________________________________________*/
BYTE	isModeCompleted = YES;		// todo 정리 : command.c에서 사용이 되어 전역변수함
BYTE 	isOnExhibition = NO;

// isOnExhibition

//////////  functions   /////////////



void main(void)///
{
	ULONG lastTime;
	int imsi=0;


	InitializeBoard();
	

	PCPrintf("EcoX - %s ", REVISION_NUM);


	Debug_foot_Log(1);
	Debug_foot_Log(3);
	
	Debug_foot_printf(1);

	testput();
	InitializeSystem();


	while(1)
	{

	}

}



/*F********************************************************************************************************
* PURPOSE:	전시회용 자동 동작
			- 터치패널에서 ROPOS 버튼을 누르면 동작 시작
			- 터치패널에서 ROPOS 버튼을 다시 누르면 동작 종료
				- 동작이 종료될 때, 로테이터는 감속해서 멈춰야 함
***********************************************************************************************************/
void Exhibition(BYTE isStart)
{
	static BYTE isReadyStop;
	static ULONG lastTime;
	static ULONG lastTime_Lamp;
	static int roStep;
	static int lampStep;
	static int stopStep;


	if(isStart == YES)
	{

		//--------------- ro 동작
		switch(roStep)
		{
			case STEP0:
			// UartPrintf("==> roStep0\r\n");
				isReadyStop = YES;
				roStep = STEP1;
			break;

			case STEP1:
			// UartPrintf("==> roStep1\r\n");
				Ctrl(RO_MAX_SPEED, (LONG) RO_MAX_PULSE);
				Ctrl(RO_SET_ORIGIN, (LONG) 0 );
				// Ctrl(RO_MOVE, (LONG) 4300);	// 440도로 움직이고
				lastTime = TimeNow();
				roStep = STEP2;
			break;

			case STEP2:
				if(!gvRO.org_complete_flag) break;

				if(TimePassed(lastTime) > ONE_SECOND)
				{
			// UartPrintf("==> roStep2\r\n");
					lastTime = TimeNow();
					roStep = STEP3;
				}
			break;

			case STEP3:
				if(TimePassed(lastTime) > ONE_SECOND)
				{
			// UartPrintf("==> roStep3\r\n");
					Ctrl(RO_MOVE, (LONG) 4350);	// 440도로 움직이고
					roStep = STEP4;
				}
			break;

			case STEP4:
				if(gvRO.stop_flag)
				{
			// UartPrintf("==> roStep4\r\n");
					lastTime = TimeNow();
					roStep = STEP5;
				} 
			break;

			case STEP5:
				if(TimePassed(lastTime) > ONE_SECOND)
				{
			// UartPrintf("==> roStep5\r\n");
					Ctrl(RO_SET_ORIGIN, (LONG) 0 );	// 원점 잡고
					roStep = STEP6;
				}
			break;

			case STEP6:
				if(gvRO.org_complete_flag)
				{
			// UartPrintf("==> roStep6\r\n");
					lastTime = TimeNow();
					roStep = STEP7;
				} 
			break;

			case STEP7:
				if(TimePassed(lastTime) > ONE_SECOND)
				{
			// UartPrintf("==> roStep7\r\n");
					Ctrl(RO_MOVE, (LONG) -800);	// -80도로 움직이고
					roStep = STEP8;
				}
			break;

			case STEP8:
				if(gvRO.stop_flag)
				{
			// UartPrintf("==> roStep8\r\n");
					lastTime = TimeNow();
					roStep = STEP9;
				}
			break;

			case STEP9:
				if(TimePassed(lastTime) > ONE_SECOND)
				{
			// UartPrintf("==> roStep9\r\n");
					Ctrl(RO_SET_ORIGIN, (LONG) 0 );	// 원점 잡고
					roStep = STEP10;
				}
			break;

			case STEP10:
				if(gvRO.org_complete_flag && gvRO.stop_flag)
				{
			// UartPrintf("==> roStep10\r\n");
					lastTime = TimeNow();
					roStep = STEP11;
				}
			break;

			//----------------- Actuator 동작
			case STEP11:
				if(TimePassed(lastTime) > ONE_SECOND)
				{
				// UartPrintf("==> roStep11\r\n");
					Ctrl(ACTUATOR_UPUP, (LONG) 0);
					lastTime = TimeNow();
					roStep = STEP12;
				}
			break;

			case STEP12:
				if(TimePassed(lastTime) > ONE_SECOND * 40)
				{
			// UartPrintf("==> roStep12\r\n");
					Ctrl(ACTUATOR_STOP, (LONG) 0);
					lastTime = TimeNow();
					roStep = STEP13;
				}
			break;


			case STEP13:
				if(TimePassed(lastTime) > ONE_SECOND * 5)
				{
			// UartPrintf("==> roStep13\r\n");
					Ctrl(ACTUATOR_DOWN, (LONG) 0);
					lastTime = TimeNow();
					roStep = STEP14;
				}
			break;

			case STEP14:
				if(TimePassed(lastTime) > ONE_SECOND * 35)	// 대략 165cm 성인의 높이에 오도록 시간조절
				{
			// UartPrintf("==> roStep14\r\n");
					Ctrl(ACTUATOR_STOP, (LONG) 0);
					lastTime = TimeNow();
					roStep = STEP15;
				}
			break;

			//----------------------- RO 동작 반복으로
			case STEP15:
				if(TimePassed(lastTime) > ONE_SECOND * 5)
				{
			// UartPrintf("==> roStep15\r\n");
					roStep = STEP1;			
				}
			break;
			
			default:	PCPuts("Undefined exhibition ro step! \r\n"); break;
		}


		//--------------- Lamp 동작
		switch(lampStep)
		{
			case STEP0:
				lastTime_Lamp = TimeNow();
				lampStep = STEP1;
			break;

			case STEP1:
				if(TimePassed(lastTime_Lamp) > ONE_SECOND * 5)
				{
					Ctrl(RDY_LAMP_ON, (LONG) 0);
					lastTime_Lamp = TimeNow();
					lampStep = STEP2;
				}
			break;

			case STEP2:
				if(TimePassed(lastTime_Lamp) > ONE_SECOND * 5)
				{
					Ctrl(EXP_LAMP_ON, (LONG) 0);
					lastTime_Lamp = TimeNow();
					lampStep = STEP3;
				}
			break;

			case STEP3:
				if(TimePassed(lastTime_Lamp) > ONE_SECOND * 5)
				{
					Ctrl(ERR_LAMP_ON, (LONG) 0);
					lastTime_Lamp = TimeNow();
					lampStep = STEP4;
				}
			break;

			case STEP4:
				if(TimePassed(lastTime_Lamp) > ONE_SECOND * 5)
				{
					Ctrl(LAMP_OFF, (LONG) 0);
					lastTime_Lamp = TimeNow();
					lampStep = STEP1;
				}
			break;
		}

	}


	//------------------------ 전시회동작 stop
	if( (isStart == NO) && (isReadyStop == YES) )
	{

		switch(stopStep)
		{
			case STEP0:
			UartPrintf("==> stopStep0 \r\n");
				Ctrl(RO_SLOW_STOP, (LONG) 0);
				Ctrl(ACTUATOR_STOP, (LONG) 0);
				Ctrl(LAMP_OFF, (LONG) 0);
				stopStep = STEP1;
			break;

			case STEP1:
				if(gvRO.stop_flag)
				{
			UartPrintf("==> stopStep1 \r\n");
					isReadyStop = NO;
					lampStep = STEP0;
					roStep = STEP0;
					stopStep = STEP0;
				}
			break;

		}
	}

}





/*F**************************************************************************
* NAME:   
* PURPOSE:
*****************************************************************************/
// command(PC, LCD ) - mode, ctrl을 처리하는 커맨드
void ProcessCmd(void)
{
	static cmd_t cmd;
	// static BYTE	isModeCompleted = YES;	// command.c에서 사용되어 extern화 됨


	// todo function : ProcessPCCmd()
	if(isModeCompleted)		
	{
		cmd = ReceiveCmd_PC();

		if( strcmp(cmd.type, "pmm") == 0 )
		{
			isModeCompleted = CmdMode(cmd.inst, cmd.value);
		}
		else if( strcmp(cmd.type, "pmc") == 0 )
		{
			Ctrl(cmd.inst, cmd.value);
		}
	}
	else
	{
		isModeCompleted = CmdMode(cmd.inst, cmd.value);
	}
}


void ProcessCmd_LCD(void)
{
	static cmd_t cmdLCD;
	static BYTE	isModeLCDCompleted = YES;
 
	

	if(isModeLCDCompleted)
	{
		cmdLCD = ReceiveCmd_LCD();

		if( strcmp(cmdLCD.type, "lmm") == 0 )
		{
			if( (cmdLCD.inst == CT) || (cmdLCD.inst == PANO_STAN) )
			{	
				isModeLCDCompleted = CmdMode_LCD(cmdLCD.inst, cmdLCD.value);
			}
			else
			{	LCDCtrl(cmdLCD.inst, cmdLCD.value);		}

			// LCDCtrl(cmd.inst, cmd.value);
		}
	}
	else
	{
		isModeLCDCompleted = CmdMode_LCD(cmdLCD.inst, cmdLCD.value);
	}
	
}



//---- dentri code

/*F********************************************************************************************************
* NAME:     exhibition

* PURPOSE:	전시회용 자동 동작
			- 터치패널에서 ROPOS 버튼을 누르면 동작 시작
			- 터치패널에서 ROPOS 버튼을 다시 누르면 동작 종료
				- 동작이 종료될 때, 로테이터는 감속해서 멈춰야 함
***********************************************************************************************************/
/*
void exhibition()
{
	switch(ex_ro_cnt)
	{
		case 0:
			ex_stop_flag = YES;	ex_stop_cnt = 0;
			
			++ex_ro_cnt;
		break;
		
		case 1:
			cmd_ctrl(RO_MAX_SPEED, "pmc_roms_17000");	// 17000 = ro_max_speed
			
			cmd_ctrl(RO_MOVE, "pmc_romv_0");
			A1_rev_turn_dly_cnt_flag = YES;
			
			++ex_ro_cnt;
		break;
		
		case 2:
			if( (ro.org_complete_flag) && (!A1_rev_turn_dly_cnt_flag) )
			{
				com2_puts("[tml_ctmd]");
				
				A1_rev_turn_dly_cnt_flag = YES;
				
				cmd_ctrl(RO_MAX_SPEED, "pmc_roms_5000");
				
				++ex_ro_cnt;
			}
		break;
		
		case 3:
			if(!A1_rev_turn_dly_cnt_flag)
			{
				cmd_ctrl(RO_MOVE, "pmc_romv_4000");
				
				++ex_ro_cnt;
			}
		break;
		
		case 4:
			if(ro.stop_flag)
			{
				A1_rev_turn_dly_cnt_flag = YES;
				
				++ex_ro_cnt;
			}
		break;
		
		case 5:
			if(!A1_rev_turn_dly_cnt_flag)
			{
				cmd_ctrl(RO_MOVE, "pmc_romv_-400");
				
				++ex_ro_cnt;
			}
		break;
		
		case 6:
			if(ro.stop_flag)
			{
				A1_rev_turn_dly_cnt_flag = YES;
				
				ex_ro_cnt = 3;
			}
		break;
		
		default:	com4_puts("Undefined ex_ro_cnt! \r\n");	break;
	}
	
	switch(ex_ac_cnt)
	{
		case 0:
			if(ex_ro_cnt > 2)	++ex_ac_cnt;
		break;
		
		case 1:
			cmd_ctrl(ACTUATOR_DOWN, "pmc_acdn");
			
			canmsg_timeover_check_flag = YES;
			++ex_ac_cnt;
		break;
		
		case 2:
			if(!canmsg_timeover_check_flag)
			{
				++acdn_cnt;
				if(acdn_cnt > 70)
				{
					cmd_ctrl(ACTUATOR_STOP, "pmc_acsp");
					
					canmsg_timeover_check_flag = YES;
					acdn_cnt = 0;	++ex_ac_cnt;
				}
				else	canmsg_timeover_check_flag = YES;
			}
		break;
		
		case 3:
			if(!canmsg_timeover_check_flag)
			{
				++acsp_cnt;
				if(acsp_cnt > 180)
				{
					cmd_ctrl(ACTUATOR_UPUP, "pmc_acup");
					
					canmsg_timeover_check_flag = YES;
					acsp_cnt = 0;	++ex_ac_cnt;
				}
				else	canmsg_timeover_check_flag = YES;
			}
		break;
		
		case 4:
			if(!canmsg_timeover_check_flag)
			{
				++acup_cnt;
				if(acup_cnt > 80)
				{
					cmd_ctrl(ACTUATOR_STOP, "pmc_acsp");
					
					canmsg_timeover_check_flag = YES;
					acup_cnt = 0;	++ex_ac_cnt;
				}
				else	canmsg_timeover_check_flag = YES;
			}
		break;
		
		case 5:
			if(!canmsg_timeover_check_flag)
			{
				++acsp_cnt;
				if(acsp_cnt > 180)
				{
					canmsg_timeover_check_flag = YES;
					acsp_cnt = 0;	ex_ac_cnt = 1;
				}
				else	canmsg_timeover_check_flag = YES;
			}
		break;
		
		default:	com4_puts("Undefined ex_ac_cnt! \r\n");	break;
	}
	
	switch(ex_lm_cnt)
	{
		case 0:
			if(!gen_preheat_time_flag)
			{
				++lm_on_cnt;
				if(lm_on_cnt > 1)
				{
					gen_preheat_time_flag = YES;
					cmd_ctrl(RDY_LAMP_ON, "pmc_relo");	lamp_ack_flag = 0;
					lm_on_cnt = 0;	++ex_lm_cnt;
				}
				else	gen_preheat_time_flag = YES;
			}
		break;
		
		case 1:
			if(!gen_preheat_time_flag)
			{
				++lm_on_cnt;
				if(lm_on_cnt > 1)
				{
					gen_preheat_time_flag = YES;
					cmd_ctrl(EXP_LAMP_ON, "pmc_exlo");	lamp_ack_flag = 0;
					lm_on_cnt = 0;	++ex_lm_cnt;
				}
				else	gen_preheat_time_flag = YES;
			}
		break;
		
		case 2:
			if(!gen_preheat_time_flag)
			{
				++lm_on_cnt;
				if(lm_on_cnt > 1)
				{
					gen_preheat_time_flag = YES;
					cmd_ctrl(ERR_LAMP_ON, "pmc_erlo");	lamp_ack_flag = 0;
					lm_on_cnt = 0;	++ex_lm_cnt;
				}
				else	gen_preheat_time_flag = YES;
			}
		break;
		
		case 3:
			if(!gen_preheat_time_flag)
			{
				++lm_on_cnt;
				if(lm_on_cnt > 1)
				{
					gen_preheat_time_flag = YES;
					cmd_ctrl(LAMP_OFF, "pmc_lmof");	lamp_ack_flag = 0;
					lm_on_cnt = 0;	ex_lm_cnt = 0;
				}
				else	gen_preheat_time_flag = YES;
			}
		break;
		
		default:	com4_puts("Undefined ex_lm_cnt! \r\n");	break;
	}
}

void ex_stop()
{
	if(ex_stop_flag)
	{
		switch(ex_stop_cnt)
		{
			case 0:
				cmd_ctrl(RO_SLOW_STOP, "pmc_rosp");
				cmd_ctrl(ACTUATOR_STOP, "pmc_acsp");
				cmd_ctrl(LAMP_OFF, "pmc_lmof");
				
				++ex_stop_cnt;
			break;
			
			case 1:
				if(ro.stop_flag)
				{
					ex_stop_flag = NO;	ex_stop_cnt = 0;
					ex_ro_cnt = 0;	ex_ac_cnt = 0;	ex_lm_cnt = 0;
					
					++ex_stop_cnt;
					
					com2_puts("[tml_ctmd]");
				}
			break;
			
			default:	com4_puts("Undefined ex_stop_cnt! \r\n");	break;
		}
	}
}
*/